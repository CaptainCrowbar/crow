#!/usr/bin/env python3

import os
import re

# General_Category                 enum           UnicodeData.txt[2]
# Canonical_Combining_Class        int            UnicodeData.txt[3]
# Canonical_Decomposition_Mapping  array(scalar)  UnicodeData.txt[5]
# XID_Continue                     bool           DerivedCoreProperties.txt
# XID_Start                        bool           DerivedCoreProperties.txt
# XID_Nonstart                     bool           (XID_Continue && ! XID_Start)
# Full_Composition_Exclusion       bool           DerivedNormalizationProps.txt
# Pattern_Syntax                   bool           PropList.txt

n_unicode = 0x110000
project = "crow"
ucd = "UCD"
source = os.path.join("source", project)
ucd_cpp = os.path.join(source, "ucd")

if re.search(r"/build(-[^/]+)?$", os.getcwd()):
    os.chdir("..")

if not re.search(fr"/{project}$", os.getcwd()):
    raise ValueError(f"Unexpected current directory: {os.getcwd()}")

for dir in [ucd, source]:
    if not os.path.isdir(dir):
        raise ValueError(f"Directory not found: {dir}")

os.makedirs(ucd_cpp, exist_ok=True)

unicode_data = os.path.join(ucd, "UnicodeData.txt")
derived_core_properties = os.path.join(ucd, "DerivedCoreProperties.txt")
derived_normalization_props = os.path.join(ucd, "DerivedNormalizationProps.txt")
prop_list = os.path.join(ucd, "PropList.txt")

gc_pattern = re.compile(r"C[cfnos]|L[lmotu]|M[cen]|N[dlo]|P[cdefios]|S[ckmo]|Z[lps]")
ccc_pattern = re.compile(r"\d+")
good_cdm_pattern = re.compile(r"[0-9a-f]{4,6}( [0-9a-f]{4,6})?", re.I)
bad_cdm_pattern = re.compile(r"<.+> .+")

general_category = ["Cn"] * n_unicode
canonical_combining_class = [0] * n_unicode
canonical_decomposition_mapping = [None] * n_unicode
xid_continue = [False] * n_unicode
xid_start = [False] * n_unicode
full_composition_exclusion = [False] * n_unicode
pattern_syntax = [False] * n_unicode

general_category_cpp = os.path.join(ucd_cpp, "general-category.cpp")
canonical_combining_class_cpp = os.path.join(ucd_cpp, "canonical-combining-class.cpp")
canonical_decomposition_mapping_cpp = os.path.join(ucd_cpp, "canonical-decomposition-mapping.cpp")
xid_continue_cpp = os.path.join(ucd_cpp, "xid-continue.cpp")
xid_start_cpp = os.path.join(ucd_cpp, "xid-start.cpp")
full_composition_exclusion_cpp = os.path.join(ucd_cpp, "full-composition-exclusion.cpp")
pattern_syntax_cpp = os.path.join(ucd_cpp, "pattern-syntax.cpp")

def format_decomposition(decomp):
    hexlist = [hex(d) for d in decomp]
    return f"{{{','.join(hexlist)}}}"

code = 0

for line in open(unicode_data):

    fields = line.split(";")

    gc = fields[2]
    if not gc_pattern.fullmatch(gc):
        raise ValueError(f"Unexpected General_Category: {gc}")
    general_category[code] = gc

    ccc = fields[3]
    if not ccc_pattern.fullmatch(ccc):
        raise ValueError(f"Unexpected Canonical_Combining_Class: {ccc}")
    canonical_combining_class[code] = int(ccc)

    cdm = fields[5]
    if cdm != "" and not bad_cdm_pattern.fullmatch(cdm):
        if not good_cdm_pattern.fullmatch(cdm):
            raise ValueError(f"Unexpected Canonical_Decomposition_Mapping: {cdm}")
        decomp = []
        for x in cdm.split():
            decomp.append(int(x, 16))
        canonical_decomposition_mapping[code] = decomp

    code += 1

with open(general_category_cpp, "w") as cpp:

    cpp.write('// This file is automatically generated\n\n')
    cpp.write('#include "crow/ucd/ucd.hpp"\n\n')
    cpp.write('namespace Crow::Detail {\n\n')
    cpp.write('    const GeneralCategoryTable& general_category_table() {\n\n')
    cpp.write('        static const GeneralCategoryTable static_table = {\n\n')

    prev = None

    for code in range(n_unicode):
        if general_category[code] != prev:
            cpp.write(f'            {{0x{code}, GC::{general_category[code]}}},\n')
            prev = general_category[code]

    cpp.write('\n')
    cpp.write('        };\n\n')
    cpp.write('        return static_table;\n\n')
    cpp.write('    }\n\n')
    cpp.write('}\n')

with open(canonical_combining_class_cpp, "w") as cpp:

    cpp.write('// This file is automatically generated\n\n')
    cpp.write('#include "crow/ucd/ucd.hpp"\n\n')
    cpp.write('namespace Crow::Detail {\n\n')
    cpp.write('    const CanonicalCombiningClassTable& canonical_combining_class_table() {\n\n')
    cpp.write('        static const CanonicalCombiningClassTable static_table = {\n\n')

    prev = None

    for code in range(n_unicode):
        if canonical_combining_class[code] != prev:
            cpp.write(f'            {{0x{code}, {canonical_combining_class[code]}}},\n')
            prev = canonical_combining_class[code]

    cpp.write('\n')
    cpp.write('        };\n\n')
    cpp.write('        return static_table;\n\n')
    cpp.write('    }\n\n')
    cpp.write('}\n')

with open(canonical_decomposition_mapping_cpp, "w") as cpp:

    cpp.write('// This file is automatically generated\n\n')
    cpp.write('#include "crow/ucd/ucd.hpp"\n\n')
    cpp.write('namespace Crow::Detail {\n\n')
    cpp.write('    const CanonicalDecompositionMappingTable& canonical_decomposition_mapping_table() {\n\n')
    cpp.write('        static const CanonicalDecompositionMappingTable static_table = {\n\n')

    for code in range(n_unicode):
        if canonical_decomposition_mapping[code] is not None:
            cpp.write(f'            {{0x{code}, {format_decomposition(canonical_decomposition_mapping[code])}}},\n')

    cpp.write('\n')
    cpp.write('        };\n\n')
    cpp.write('        return static_table;\n\n')
    cpp.write('    }\n\n')
    cpp.write('}\n')
